package client

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"time"

	"github.com/pkg/errors"
)

type RuntimePolicy struct {
	Name                         string                       `json:"name"`
	Description                  string                       `json:"description"`
	Author                       string                       `json:"author"`
	Version                      string                       `json:"version"`
	Lastupdate                   int                          `json:"lastupdate"`
	Enabled                      bool                         `json:"enabled"`
	Type                         string                       `json:"type"`
	RuntimeType                  string                       `json:"runtime_type"`
	Enforce                      bool                         `json:"enforce"`
	AllowedExecutables           AllowedExecutables           `json:"allowed_executables"`
	ExecutableBlacklist          ExecutableBlacklist          `json:"executable_blacklist"`
	DriftPrevention              DriftPrevention              `json:"drift_prevention"`
	RestrictedVolumes            RestrictedVolumes            `json:"restricted_volumes"`
	NoNewPrivileges              bool                         `json:"no_new_privileges"`
	BypassScope                  BypassScope                  `json:"bypass_scope"`
	LimitContainerPrivileges     LimitContainerPrivileges     `json:"limit_container_privileges"`
	PreventOverrideDefaultConfig PreventOverrideDefaultConfig `json:"prevent_override_default_config"`
	Scope                        Scope                        `json:"scope"`
	OnlyRegisteredImages         bool                         `json:"only_registered_images"`
	BlockDisallowedImages        bool                         `json:"block_disallowed_images"`
	BlockNonCompliantWorkloads   bool                         `json:"block_non_compliant_workloads"` //
	Auditing                     Auditing                     `json:"auditing"`
	BlacklistedOsUsers           BlacklistedOsUsers           `json:"blacklisted_os_users"`
	WhitelistedOsUsers           WhitelistedOsUsers           `json:"whitelisted_os_users"`
	DefaultSecurityProfile       string                       `json:"default_security_profile"`
	EnableForkGuard              bool                         `json:"enable_fork_guard"`
	ForkGuardProcessLimit        int                          `json:"fork_guard_process_limit"`
	EnableIPReputation           bool                         `json:"enable_ip_reputation"`
	EnablePortScanProtection     bool                         `json:"enable_port_scan_protection"`
	BlockNwUnlinkCont            bool                         `json:"block_nw_unlink_cont"`
	FileBlock                    FileBlock                    `json:"file_block"`
	PackageBlock                 PackageBlock                 `json:"package_block"`
	LinuxCapabilities            LinuxCapabilities            `json:"linux_capabilities"`
	PortBlock                    PortBlock                    `json:"port_block"`
	Tripwire                     Tripwire                     `json:"tripwire"`
	FileIntegrityMonitoring      FileIntegrityMonitoring      `json:"file_integrity_monitoring"`
	RegistryAccessMonitoring     RegistryAccessMonitoring     `json:"registry_access_monitoring"`
	ReadonlyRegistry             ReadonlyRegistry             `json:"readonly_registry"`
	SystemIntegrityProtection    SystemIntegrityProtection    `json:"system_integrity_protection"`
	BlockContainerExec           bool                         `json:"block_container_exec"`
	VulnID                       int                          `json:"vuln_id"`
	RepoID                       int                          `json:"repo_id"`
	HeuristicRefID               int                          `json:"heuristic_ref_id"`
	ImageID                      int                          `json:"image_id"`
	IsAutoGenerated              bool                         `json:"is_auto_generated"`
	ApplicationScopes            []string                     `json:"application_scopes"`
	Registry                     string                       `json:"registry"`
	AuditOnFailure               bool                         `json:"audit_on_failure"`
	FailCicd                     bool                         `json:"fail_cicd"`
	BlockFailed                  bool                         `json:"block_failed"`
	EnforceAfterDays             int                          `json:"enforce_after_days"`
	DomainName                   string                       `json:"domain_name"`
	Domain                       string                       `json:"domain"`
	ReadonlyFiles                ReadonlyFiles                `json:"readonly_files"`
	Updated                      time.Time                    `json:"updated"`
	EnforceSchedulerAddedOn      int                          `json:"enforce_scheduler_added_on"`
	IsAuditChecked               bool                         `json:"is_audit_checked"`
	Permission                   string                       `json:"permission"`
	ImageName                    string                       `json:"image_name"`
	RepoName                     string                       `json:"repo_name"`
	Cve                          string                       `json:"cve"`
	ResourceType                 string                       `json:"resource_type"`
	ResourceName                 string                       `json:"resource_name"`
	VpatchVersion                string                       `json:"vpatch_version"`
	Digest                       string                       `json:"digest"`
	Created                      time.Time                    `json:"created"`
}

type AllowedExecutables struct {
	Enabled              bool     `json:"enabled"`
	AllowExecutables     []string `json:"allow_executables"`
	SeparateExecutables  bool     `json:"separate_executables"`
	AllowRootExecutables []string `json:"allow_root_executables"`
}

type ExecutableBlacklist struct {
	Enabled     bool     `json:"enabled"`
	Executables []string `json:"executables"`
}

type DriftPrevention struct {
	Enabled           bool `json:"enabled"`
	ExecLockdown      bool `json:"exec_lockdown"`
	ImageLockdown     bool `json:"image_lockdown"`
	PreventPrivileged bool `json:"prevent_privileged"`
}

type RestrictedVolumes struct {
	Enabled bool     `json:"enabled"`
	Volumes []string `json:"volumes"`
}

type BypassScope struct {
	Enabled bool  `json:"enabled"`
	Scope   Scope `json:"scope"`
}

type LimitContainerPrivileges struct {
	Enabled               bool `json:"enabled"`
	Privileged            bool `json:"privileged"`
	Netmode               bool `json:"netmode"`
	Pidmode               bool `json:"pidmode"`
	Utsmode               bool `json:"utsmode"`
	Usermode              bool `json:"usermode"`
	Ipcmode               bool `json:"ipcmode"`
	PreventRootUser       bool `json:"prevent_root_user"`
	PreventLowPortBinding bool `json:"prevent_low_port_binding"`
	BlockAddCapabilities  bool `json:"block_add_capabilities"`
	UseHostUser           bool `json:"use_host_user"`
}

type PreventOverrideDefaultConfig struct {
	Enabled         bool `json:"enabled"`
	EnforceSelinux  bool `json:"enforce_selinux"`
	EnforceSeccomp  bool `json:"enforce_seccomp"`
	EnforceApparmor bool `json:"enforce_apparmor"`
}

type Auditing struct {
	Enabled             bool `json:"enabled"`
	AuditAllProcesses   bool `json:"audit_all_processes"`
	AuditProcessCmdline bool `json:"audit_process_cmdline"`
	AuditAllNetwork     bool `json:"audit_all_network"`
	AuditOsUserActivity bool `json:"audit_os_user_activity"`
}

type BlacklistedOsUsers struct {
	Enabled        bool     `json:"enabled"`
	UserBlackList  []string `json:"user_black_list"`
	GroupBlackList []string `json:"group_black_list"`
}

type WhitelistedOsUsers struct {
	Enabled        bool     `json:"enabled"`
	UserWhiteList  []string `json:"user_white_list"`
	GroupWhiteList []string `json:"group_white_list"`
}

type FileBlock struct {
	Enabled           bool     `json:"enabled"`
	FilenameBlockList []string `json:"filename_block_list"`
}

type PackageBlock struct {
	Enabled           bool     `json:"enabled"`
	PackagesBlackList []string `json:"packages_black_list"`
}

type LinuxCapabilities struct {
	Enabled                 bool     `json:"enabled"`
	RemoveLinuxCapabilities []string `json:"remove_linux_capabilities"`
}

type PortBlock struct {
	Enabled            bool     `json:"enabled"`
	BlockInboundPorts  []string `json:"block_inbound_ports"`
	BlockOutboundPorts []string `json:"block_outbound_ports"`
}

type Tripwire struct {
	Enabled       bool     `json:"enabled"`
	UserID        string   `json:"user_id"`
	UserPassword  string   `json:"user_password"`
	ApplyOn       []string `json:"apply_on"`
	ServerlessApp string   `json:"serverless_app"`
}

type FileIntegrityMonitoring struct {
	Enabled                            bool     `json:"enabled"`
	MonitoredFiles                     []string `json:"monitored_files"`
	ExceptionalMonitoredFiles          []string `json:"exceptional_monitored_files"`
	MonitoredFilesProcesses            []string `json:"monitored_files_processes"`
	ExceptionalMonitoredFilesProcesses []string `json:"exceptional_monitored_files_processes"`
	MonitoredFilesUsers                []string `json:"monitored_files_users"`
	ExceptionalMonitoredFilesUsers     []string `json:"exceptional_monitored_files_users"`
	MonitoredFilesCreate               bool     `json:"monitored_files_create"`
	MonitoredFilesRead                 bool     `json:"monitored_files_read"`
	MonitoredFilesModify               bool     `json:"monitored_files_modify"`
	MonitoredFilesDelete               bool     `json:"monitored_files_delete"`
	MonitoredFilesAttributes           bool     `json:"monitored_files_attributes"`
}

type RegistryAccessMonitoring struct {
	Enabled                               bool     `json:"enabled"`
	MonitoredRegistryPaths                []string `json:"monitored_registry_paths"`
	ExceptionalMonitoredRegistryPaths     []string `json:"exceptional_monitored_registry_paths"`
	MonitoredRegistryProcesses            []string `json:"monitored_registry_processes"`
	ExceptionalMonitoredRegistryProcesses []string `json:"exceptional_monitored_registry_processes"`
	MonitoredRegistryUsers                []string `json:"monitored_registry_users"`
	ExceptionalMonitoredRegistryUsers     []string `json:"exceptional_monitored_registry_users"`
	MonitoredRegistryCreate               bool     `json:"monitored_registry_create"`
	MonitoredRegistryRead                 bool     `json:"monitored_registry_read"`
	MonitoredRegistryModify               bool     `json:"monitored_registry_modify"`
	MonitoredRegistryDelete               bool     `json:"monitored_registry_delete"`
	MonitoredRegistryAttributes           bool     `json:"monitored_registry_attributes"`
}

type SystemIntegrityProtection struct {
	Enabled                   bool `json:"enabled"`
	AuditSystemtimeChange     bool `json:"audit_systemtime_change"`
	WindowsServicesMonitoring bool `json:"windows_services_monitoring"`
}

type ReadonlyFiles struct {
	Enabled                  bool     `json:"enabled"`
	ReadonlyFiles            []string `json:"readonly_files"`
	ExceptionalReadonlyFiles []string `json:"exceptional_readonly_files"`
}

type ReadonlyRegistry struct {
	Enabled                              bool     `json:"enabled"`
	ReadonlyRegistryPaths                []string `json:"readonly_registry_paths"`
	ExceptionalReadonlyRegistryPaths     []string `json:"exceptional_readonly_registry_paths"`
	ReadonlyRegistryProcesses            []string `json:"readonly_registry_processes"`
	ExceptionalReadonlyRegistryProcesses []string `json:"exceptional_readonly_registry_processes"`
	ReadonlyRegistryUsers                []string `json:"readonly_registry_users"`
	ExceptionalReadonlyRegistryUsers     []string `json:"exceptional_readonly_registry_users"`
}

// CreateRuntimePolicy creates an Aqua RuntimePolicy
func (cli *Client) CreateRuntimePolicy(runtimePolicy *RuntimePolicy) error {
	payload, err := json.Marshal(runtimePolicy)
	if err != nil {
		return err
	}

	request := cli.gorequest
	request.Set("Authorization", "Bearer "+cli.token)
	apiPath := fmt.Sprintf("/api/v2/runtime_policies")
	resp, body, errs := request.Clone().Post(cli.url + apiPath).Send(string(payload)).End()
	if errs != nil {
		return errors.Wrap(getMergedError(errs), "failed creating runtime policy.")
	}
	if resp.StatusCode != 200 && resp.StatusCode != 201 && resp.StatusCode != 204 {
		var errorResponse ErrorResponse
		err = json.Unmarshal([]byte(body), &errorResponse)
		if err != nil {
			log.Printf("Failed to Unmarshal response Body to ErrorResponse. Body: %v", body)
			return fmt.Errorf("failed creating runtime policy with name %v. Status: %v, Response: %v", runtimePolicy.Name, resp.StatusCode, body)
		}
		return fmt.Errorf("failed creating runtime policy. status: %v. error message: %v", resp.Status, errorResponse.Message)
	}

	return nil
}

// GetRuntimePolicy gets an Aqua runtime policy by name
func (cli *Client) GetRuntimePolicy(name string) (*RuntimePolicy, error) {
	var err error
	var response RuntimePolicy
	request := cli.gorequest
	apiPath := fmt.Sprintf("/api/v2/runtime_policies/%v", name)
	request.Set("Authorization", "Bearer "+cli.token)
	events, body, errs := request.Clone().Get(cli.url + apiPath).End()
	if errs != nil {
		return nil, errors.Wrap(getMergedError(errs), "failed getting runtime policy with name "+name)
	}
	if events.StatusCode == 200 {
		err = json.Unmarshal([]byte(body), &response)
		if err != nil {
			log.Printf("Error unmarshaling response body")
			return nil, errors.Wrap(err, fmt.Sprintf("couldn't unmarshal get runtime policy response. Body: %v", body))
		}
	} else {
		var errorReponse ErrorResponse
		err = json.Unmarshal([]byte(body), &errorReponse)
		if err != nil {
			log.Println("failed to unmarshal error response")
			return nil, fmt.Errorf("failed getting runtime policy with name %v. Status: %v, Response: %v", name, events.StatusCode, body)
		}

		return nil, fmt.Errorf("failed getting runtime policy with name %v. Status: %v, error message: %v", name, events.StatusCode, errorReponse.Message)
	}

	return &response, nil
}

// UpdateRuntimePolicy updates an existing runtime policy policy
func (cli *Client) UpdateRuntimePolicy(runtimePolicy *RuntimePolicy) error {
	payload, err := json.Marshal(runtimePolicy)
	if err != nil {
		return err
	}
	request := cli.gorequest
	request.Set("Authorization", "Bearer "+cli.token)
	apiPath := fmt.Sprintf("/api/v2/runtime_policies/%s", runtimePolicy.Name)
	resp, _, errs := request.Clone().Put(cli.url + apiPath).Send(string(payload)).End()
	if errs != nil {
		return errors.Wrap(getMergedError(errs), "failed modifying runtime policy")
	}
	if resp.StatusCode != 201 && resp.StatusCode != 204 {
		body, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Printf("Failed to read response Body")
			return err
		}
		var errorResponse ErrorResponse
		err = json.Unmarshal(body, &errorResponse)
		if err != nil {
			log.Printf("Failed to Unmarshal response Body to ErrorResponse. Body: %v. error: %v", string(body), err)
			return err
		}
		return fmt.Errorf("failed modifying runtime policy. status: %v. error message: %v", resp.Status, errorResponse.Message)
	}
	return nil
}

// DeleteRuntimePolicy removes a Aqua runtime policy
func (cli *Client) DeleteRuntimePolicy(name string) error {
	request := cli.gorequest
	request.Set("Authorization", "Bearer "+cli.token)
	apiPath := fmt.Sprintf("/api/v2/runtime_policies/%s", name)
	resp, body, errs := request.Clone().Delete(cli.url + apiPath).End()
	if errs != nil {
		return errors.Wrap(getMergedError(errs), "failed deleting runtime policy")
	}
	if resp.StatusCode != 204 {
		var errorResponse ErrorResponse
		err := json.Unmarshal([]byte(body), &errorResponse)
		if err != nil {
			log.Printf("Failed to Unmarshal response Body to ErrorResponse. Body: %v.", body)
			return err
		}
		return fmt.Errorf("failed deleting runtime policy, status: %v. error message: %v", resp.Status, errorResponse.Message)
	}
	return nil
}
